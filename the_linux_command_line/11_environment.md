# The environment
- The shell maintains a body of information during our shell session called the *environment*. Programs use the data stored in the environment to determine facts about the system’s **configuration**
- While most programs use *configuration files* to store program settings, some programs also look for values stored in the environment to **adjust** their behavior
## What is stored in the environment
- The shell stores **2 basic types** of data in the environment; though, with `bash`, the types are largely **indistinguishable**. They are *environment variables* and *shell variables*
- Shell variables are bits of data placed there by `bash`, and environment variables are everything else
- In addition to variables, the shell stores some programmatic data, namely, *aliases* and *shell functions*
### Examining the environment
- Use either the `set` builtin in bash or the `printenv` program
- The `set` command will show **both** the shell and environment variables, while `printenv` will display only **environment variables**
	
    ```bash
    printenv | less
    printenv USER

    set | less

    echo $HOME
    ```

    - The `set` command, when used without options or arguments, will display **both the shell and environment variables**, as well as any **defined shell functions**. Unlike `printenv`, its output is courteously sorted in **alphabetical order**
- One element of the environment that neither `set` nor `printenv` displays is aliases. To see them, enter the `alias` command without arguments
### Some variables
- Environment variables vary by distribution

Variable | Contents |
--|--|
DISPLAY | The name of your display if you are running a graphical environment. Usually this is `:0`, meaning the first display generated by the X server.
EDITOR | The name of the program to be used for text editing.
SHELL | The name of your shell program.
HOME | The pathname of your home directory.
LANG | Defines the character set and collation order of your language.
OLDPWD | The previous working directory.
PAGER | The name of the program to be used for paging output. This is often set to `/usr/bin/less`.
PATH | A **colon-separated** list of directories that are searched when you enter the name of a executable program.
PS1 | Stands for “prompt string 1.“ This defines the contents of the shell prompt. This can be extensively customized.
PWD | The current working directory.
TERM | The name of your terminal type. Unix-like systems support many **terminal protocols**; this variable sets the protocol to be used with your terminal emulator.
TZ | Specifies your time zone. Most Unix-like systems **maintain** the computer’s internal clock in Coordinated Universal Time (**UTC**) and then display the local time by **applying an offset** specified by this variable.
USER | Your username.
|

## How is the environment established
- When we log on to the system, the `bash` program starts and reads a series of configuration scripts called *startup files*, which define the default environment **shared by all users**. This is **followed** by more startup files in our **home directory** that define our **personal environment**. 
- The exact sequence depends on the **type of shell session** being started. There are 2 kinds
    1. A login shell session
        - This is one in which we are **prompted for our username and password**. This happens when we start a virtual console session, for example
    2. A non-login shell session
        - This typically occurs when we **launch a terminal session in the GUI**
- Startup Files for Login Shell Sessions

    File | Contents |
    --|--|
    `/etc/profile` | A global configuration script that applies to all users.
    `~/.bash_profile` | A user’s personal startup file. It can be used to **extend** or **override** settings in the global configuration script.
    `~/.bash_login` | If `~/.bash_profile` is not found, `bash` attempts to read this script.
    `~/.profile` | If neither `~/.bash_profile` nor `~/.bash_login` is found, `bash` attempts to read this file. This is the default in Debian-based distributions, such as Ubuntu.
    |

- Startup Files for Non-Login Shell Sessions

    File | Contents |
    --|--|
    `/etc/bash.bashrc` | A global configuration script that applies to all users.
    `~/.bashrc` | A user’s personal startup file. It can be used to extend or override settings in the global configuration script.
    |

    - In addition to reading the startup files listed, non-login shells **inherit** the environment from their **parent process**, usually a login shell
- The **`~/.bashrc`** file is probably the most important startup file from the ordinary user’s point of view, because it is almost always read. Non-login shells read it by default, and most **startup files for login shells** are **written** in such a way as **to read** the `~/.bashrc` file as well
### What's in a startup file
- `.bash_profile`
	
    ```sh
    # .bash_profile
    # Get the aliases and functions
    if [ -f ~/.bashrc ]; then   # if exists
        . ~/.bashrc             # read it
    fi

    # User specific environment and startup programs
    PATH=$PATH:$HOME/bin
    export PATH
    ```

    - `PATH` is modified to add the directory `$HOME/bin` to the end of the list. This is an example of *parameter expansion*
    	
        ```bash
        foo="This is some "
        echo $foo
        # This is some
        foo=$foo"text."
        echo $foo
        # This is some text.
        ```
    
        - Using this technique, we can **append** text to the end of a variable’s contents
        - By adding the string `$HOME/bin` to the end of the `PATH` variable’s contents, the directory `$HOME/bin` is added to the list of directories searched when a command is entered
            - When we enter `ls`, the shell does not search the entire computer to find `/bin/ls` (the full pathname of the `ls` command); rather, it searches a list of directories that are contained in the `PATH` variable
    - The `export` command tells the shell to make the contents of `PATH` **available** to **child processes of this shell**
- The `PATH` variable is often (but not always, depending on the distribution) set by the `/etc/profile` startup file with this code
	
    ```sh
    PATH=$PATH:$HOME/bin
    ```

    - Many distributions provide this `PATH` setting by default. Debian-based distributions, such as Ubuntu, test for the existence of the `~/bin` directory at login and **dynamically** add it to the `PATH` variable if the directory is found
## Modifying the environment
### Which files should we modify
- As a general rule, to add directories to your **`PATH`** or define additional **environment variables**, place those changes in `.bash_profile` (or the equivalent, according to your distribution; for example, Ubuntu uses `.profile`). For everything else, place the changes in `.bashrc`
    - Unless you are the system administrator and need to change the defaults for all users of the system, **restrict** your modifications to the files in your home directory. It is certainly possible to change the files in `/etc` such as `profile`, and in many cases it would be sensible to do so, but for now, let’s play it safe
### Text editors
- Text editors fall into 2 basic categories: graphical and **text-based**
- GNOME and KDE both include some popular graphical editors
    - GNOME ships with an editor called `gedit`, which is usually called “Text Editor” in the GNOME menu
    - KDE usually ships with 3, which are (in order of increasing complexity) `kedit`, `kwrite`, and `kate`
- The popular text-based editors we’ll encounter are `nano`, `vi`, and `emacs`
    - The `nano` editor is a simple, easy-to-use editor designed as a replacement for the `pico` editor supplied with the PINE email suite
    - The `vi` editor (which on most Linux systems has been replaced by a program named `vim`, which is short for “vi improved”) is the traditional editor for Unix-like systems
    - The `emacs` editor was originally written by Richard Stallman. It is a gigantic, all-purpose, does-everything programming environment. While readily available, it is seldom installed on most Linux systems by default
### Using a text editor
- Text editors can be invoked from the command line by typing the name of the editor followed by the name of the file you want to edit. If the file does not already exist, the editor will **assume** that we want to **create** a new file
- Whenever we edit an important configuration file, it is always a good idea to create a backup copy of the file first
	
    ```bash
    cp .bashrc .bashrc.bak
    nano .bashrc
    ```

    - `^` means `ctrl`
    - Duplicates in `.bashrc` won’t hurt
    - `export HISTCONTROL=ignoredups` causes the shell’s history recording feature to ignore a command if the same command was just recorded
    - `export HISTSIZE=1000` increases the size of the command history from the usual default of 500 lines to 1,000 lines
    - `alias l.='ls -d .* --color=auto'` creates a new command called `l.`, which displays all directory entries that begin with a dot
- Whenever you modify configuration files, it’s a good idea to add some comments to document your changes
- Shell scripts and bash startup files use a `#` symbol to begin a comment. Other configuration files may use other symbols. Most configuration files will have comments
    - You will often see lines in configuration files that are commented out to prevent them from being used by the affected program. This is done to give the reader **suggestions** for possible configuration choices or **examples of correct configuration syntax**
### Activating changes
- The changes we have made to our `.bashrc` will not take effect until we close our terminal session and start a new one because the `.bashrc` file is **read only at the beginning of a session**
- Force bash to **reread** the modified `.bashrc` file with the following command
	
    ```bash
    source ~/.bashrc
    ```

## Summing up
- Moving forward, as we read man pages for commands, take note of the environment variables that commands support
- Shell functions can also be included in the `bash` startup files